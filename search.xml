<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 小知识点]]></title>
    <url>%2F2018%2F12%2F12%2FJava-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[123456public void test()&#123; String s0="helloworld"; String s1="helloworld"; System.out.println(s0==s1); //true s0跟s1是指向同一个对象&#125; 123456public void test4()&#123; String s0="helloworld"; String s1=new String("helloworld"); System.out.println( s0==s1 ); //false s0跟s1是不同的对象&#125; “==”操作符的作用 用于基本数据类型的比较 判断引用是否指向堆内存的同一块地址。 12345String s1 = new String("java");String s2 = new String("java");System.out.println(s1==s2); //falseSystem.out.println(s1.equals(s2)); //true 所以字符串比较尽量用equals]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Packet Tracer中的命令]]></title>
    <url>%2F2018%2F12%2F10%2FPacket-Tracer%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[密码设置： 特权EXEC模式密码： 在全局配置下， &gt;&gt;enbale secret + … 线路密码： 全局模式下，&gt;&gt;line console 0 &gt;&gt; password + … &gt;&gt;login 加密显示密码： service password-encryption 设置警告标语： banner motd #Legal action will be pursued for any unauthorized use# 显示路由器的 MAC 地址两种方式： 通过控制台连接到 R1 并使用 show interfaces g0/1 命令查找 MAC 另一种显示路由器上 MAC 地址的方法是使用 show arp 命令。使用 show arp 命令显示 MAC 地址信息。 此命令将第 2 层地址映射到与其对应的第 3 层地址。 查看交换机上的 MAC 地址 show interfaces show mac address-table 在 Cisco IOS 路由器上，show ip route 命令可用于显示路由器的路由表 查看运行的配置文件 show running-config 用于将运行配置文件保存到启动配置文件的命令为：copy running-config startup-config （即保存到NVRAM） 删除启动配置文件 erase NVRAM:startup-config 用于从全局配置模式导航到接口配置模式 interface vlan 1 ip address 192.168.10.2 255.255.255.0 no shutdown 设置线路ip地址 ip default-gateway ….. 设置默认网关 Cisco 1941 路由器配备有两个千兆以太网接口和一个由两个接口组成的串行 WAN 接口卡 (WIC)；接口的命名方式如下： Gigabit Ethernet 0/0 (G0/0) Gigabit Ethernet 0/1 (G0/1) Serial 0/0/0 (S0/0/0) Serial 0/0/1 (S0/0/1) 交换机 IP 地址要在交换机虚拟接口 (SVI) 上配置 interface Vlan1 ip address 192.168.10.50 255.255.255.0 no shut 重命名交换机 hostname … R1(config)# ipv6 unicast-routing 让路由器转发ipv6 ipv6 address 2001:DB8:1:1::1/64 配置ipv6地址 ipv6 address FE80::1 link-local]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer66]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%89%91%E6%8C%87offer66%2F</url>
    <content type="text"><![CDATA[25 该题难点在随机指针的复制，复制的随机指针应该与原先的随机指针指向相同的相对位置，所以我的做法是在原先链表中先插空复制，这样做的目的是知道随机指针的指向，然后再分离出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if (pHead == NULL) return NULL; //double RandomListNode *p = pHead, *q=NULL; while (p!=NULL) &#123; q = new RandomListNode(p-&gt;label); q-&gt;next = p-&gt;next; p-&gt;next = q; p = p-&gt;next-&gt;next; &#125; //random p = pHead; while (p != NULL) &#123; if (p-&gt;random == NULL) p-&gt;next-&gt;random = NULL; else p-&gt;next-&gt;random = p-&gt;random-&gt;next; p = p-&gt;next-&gt;next; &#125; //seperate p = pHead; RandomListNode *qHead = NULL; q = NULL; while (p != NULL) &#123; if (q == NULL) &#123; q = p-&gt;next; qHead = q; p-&gt;next = p-&gt;next-&gt;next; &#125; else &#123; q-&gt;next = p-&gt;next; q = q-&gt;next; p-&gt;next = p-&gt;next-&gt;next; &#125; p = p-&gt;next; &#125; return qHead; &#125;&#125;; 26 有序链表就是BST的中序遍历，这个题可以用递归解决，每次我们将跟节点与左/右边排好序的双向链表链接，函数返回最小的（也就是最左边的）数的指针。那么对于左边，我们需要链接最右边的节点，所以需要定位到最右边。我用的是双向链表，这样就可以O(1)定位。 123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* getList(TreeNode* root)&#123; if(root==NULL) return NULL; TreeNode *List=getList(root-&gt;left), *leftMost=root, *rightMost=root; if(List!=NULL)&#123; leftMost=List; List=List-&gt;left; List-&gt;right=root; root-&gt;left=List; &#125; List=getList(root-&gt;right); if(List!=NULL)&#123; rightMost=List-&gt;left; List-&gt;left=root; root-&gt;right=List; &#125; leftMost-&gt;left=rightMost; rightMost-&gt;right=leftMost; return leftMost; &#125; TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(pRootOfTree==NULL) return NULL; TreeNode* Head=NULL; Head=getList(pRootOfTree); Head-&gt;left-&gt;right=NULL; Head-&gt;left=NULL; return Head; &#125;&#125;; 27 这个题要求 无重复全排列 字典序 所以递归的时候要做到几点 和第pos个位置相同的不交换 swap完之后不要交换回去（这个不明白，是看了别人那样做的） 基于第二点，递归str不能传递引用 123456789101112131415161718192021222324class Solution &#123;public: void getPer(int pos, int sz, vector&lt;string&gt;&amp; ans, string str) &#123; if (pos == sz) &#123; ans.push_back(str); return; &#125; for (int i = pos; i &lt; sz; i++) &#123; if (i != pos &amp;&amp; str[i] == str[pos]) continue; swap(str[pos], str[i]); getPer(pos + 1, sz, ans, str); &#125; &#125; vector&lt;string&gt; Permutation(string str) &#123; sort(str.begin(), str.end()); vector&lt;string&gt; ans; if (str.length() == 0) return ans; getPer(0, str.length(), ans, str); return ans; &#125;&#125;; 28 思路比较好的题，自己本能反应是用unordered_map， 其实用一个出现次数变量，如果有出现次数超过n/2的数，最后通过相同+， 不同-， 最后剩下的肯定是符合的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int ans=0, f=0, ci=0; int sz=numbers.size(); for(auto i : numbers)&#123; if(i==ans)&#123; f++; &#125; else&#123; if(f==0)&#123; ans=i; f=1; &#125; else&#123; f--; &#125; &#125; &#125; for(auto i : numbers)&#123; if(i==ans) ci++; &#125; if(ci*2&gt;sz) return ans; return 0; &#125;&#125;; 40 这道题的思路特别巧妙，找数组出现次数只有一次的两个数。利用抑或运算的性质，所有数的^和就是所求两数的^和，在用该^的最低位，将所有数分为包含该位和不包含该位的两组，^完即可得到结果。 123456789101112131415161718class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int oxr=0; for(auto i:data)&#123; oxr^=i; &#125; int lowbit=oxr&amp;-oxr; *num1=0; *num2=0; for(auto i:data)&#123; if(i&amp;lowbit) *num1^=i; else *num2^=i; &#125; return; &#125;&#125;; 52 这道题考验自己的分析归纳能力吧。 （1）若pattern第i+1个字符是‘*’ ①若str和pattern第i个字符相等（包括任意字符和’.’匹配），可以选择匹配，也可以选择不匹配 ②若第i个字符不相等，一定是‘*’代表出现0次 （2）若pattern第i+1不是‘*’ ①若可以匹配则缩短字符串 ②若不可以匹配则返回false 这样递归的缩短字符串 最后两个串是空则返回true，若pattern为空而str不为空，返回false。 12345678910111213141516171819202122class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(*str==0 &amp;&amp; *pattern==0) return true; if(*str!=0 &amp;&amp; *pattern==0) return false; if(*(pattern+1)=='*')&#123; if(*str==*pattern || *str!=0 &amp;&amp; *pattern=='.') return match(str+1, pattern) || match(str, pattern+2); else return match(str, pattern+2); &#125; else&#123; if(*str==*pattern || *str!=0 &amp;&amp; *pattern=='.') return match(str+1, pattern+1); else return false; &#125; &#125;&#125;; 63 写这道题的目的不是为了思路，而是记录一下自己犯的致命的错误，一定要注意数据类型的区别，比如下面这个例子 12345678910priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; gq;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; lq;if(lq.size()-gq.size()&gt;1)&#123; gq.push(lq.top()); lq.pop();&#125;else if (gq.size()&gt;lq.size())&#123; lq.push(gq.top(); gq.pop();&#125; 因为size()是size_type类型，size_type 是 unsigned int，所以如果第三行相减成了负值，因为是unsigned，所以会变成很大的数。应该把值赋值给int，再相减 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; gq; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; lq;public: void Insert(int num) &#123; if(lq.empty() || lq.top()&lt;=num) lq.push(num); else gq.push(num); int sz1=lq.size(), sz2=gq.size(); if(sz1-sz2&gt;1)&#123; gq.push(lq.top()); lq.pop(); &#125; else if(sz2&gt;sz1)&#123; lq.push(gq.top()); gq.pop(); &#125; &#125; double GetMedian() &#123; int sz=lq.size()+gq.size(); if(sz==0) return 0.0; if(sz&amp;1) return lq.top(); else return 0.5*(lq.top()+gq.top()); &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3sum-leetcode 15]]></title>
    <url>%2F2018%2F11%2F29%2F3sum-leetcode-15%2F</url>
    <content type="text"><![CDATA[题意： 给n个数，寻找和为0的三元组，去重。不管target和是几，也不管是几元组，假如是找k元组，这种题的的套路是： 排序 外层k-2个循环枚举k-2个数 剩下两个数用双指针，从两端寻找 所以总的时间复杂度是O(n^(k-1))。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; int sz = nums.size(); if (sz == 0) return ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; sz; i++) &#123; if (i &amp;&amp; nums[i] == nums[i - 1]) continue; int j = i + 1, k = sz - 1; while (j &lt; k) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; ans.push_back(&#123; nums[i], nums[j], nums[k] &#125;); while (j &lt; sz &amp;&amp; nums[++j] == nums[j - 1]); &#125; else if (nums[i] + nums[j] + nums[k] &lt; 0) while (j &lt; sz &amp;&amp; nums[++j] == nums[j - 1]); else while (k &gt; j &amp;&amp; nums[--k] == nums[k + 1]); &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-11-26]]></title>
    <url>%2F2018%2F11%2F26%2F2018-11-26%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1899/FpSUXeVXfHymI4YURLixlfT6WoEsW+e+PmXk15aEHSUKkSXQ1uKaesjGyEVcT3Ltt6xOmVCWlno1Tdqa5W+rPY7P3tZVp9scXY4G/4+T2B4exSoBjUEy0un7L+Fgz34CV6Tm29g2jhFKOq0xqdHpxLhOZKQoRizD3tmj5IN7gVDVYGC6+uqFFOcxXhWx9sUikVRgOV7olvScX7f54DxArUzUbR/VAWtddj7TU985Td9lAuCa4Z6503N/a7o/XrOl0pYODIN+Hwk2R6m93aMpYdsar+g3IrmIziPMR4Q+jRdTaVj6LqQP+rkVhrOIER8bHybEnLvX12rgEI6BfuzeXAq/DqA4Uew21XGU8FSFKsokhUBv67vXqHx5atVYLrlVEzT6JLyfI9sJ67rdtErGYULjwnTnoLdPsxG89fAFtB37q5qdv0WD8jVTLYPfHLoogP3xgBg1OkzcHg6M5g+HuNsrDp56IbfgWzLZ5aNyrBUWVxApaicqvN8ckek+skkoQH6dJdvF7J4Zf2nZd4OlbbJ+gfmlzM6VkCRq6HGk1pAG5EhVMq+YVYUWImeHDchsd3x/xZ2BUUbaS5eBhPOXbdxHC/lcJAqLV1/Cd3Wp1nMe5qsURS8dGrbje74w/oHo+vQ/YiU4djABZBOIXQUn40Y18bUGlqgysdfMLgDPCrQyzYxr66wHGSnSlEagVLouwBhZE4LyfOflpTLQKCPg/7e7WghzeMfMwPwwVyJ5tOKbKGbG9Gz2/5ajL1zl4wQ9saioaJs+Stn1yzgU0fngmsYAMJjtbyyRcdAlQVSquphaP5cm2IIlWlIcc79uytnAqQfgY9dBzmR8rYI+v85NkcoTzCdTlkSZkh/rKu+2J0+3+MWgUpDKbD+BR9I7+SzP4nVBzabMybZhheK4TrPh4hq5dc8fbGq6ohHfh/Zjy2s/lsBcG8Xcmnhexih3umD4wkxo30yUrRQy2SyCQexleSWqjHIwl5Ob+ei7MuMaAJHwnK3VlCnHSwj0AcdQJqYDuW62C6kQon6hb4pWKXCIoz6STI40ot8BbuC0+Jl4QiHzBt4y1PCHdVitlaXaRk7Mmmighak0TUqjACX10IqM0ZTAYk4uBTEDH6Inzlgpm8QRQ+I2TSBaD9ke2ki70geHEu6Vdk3FJ9NAnz/rp6opnJ8aRb066pxrI8rTwD+OTxIBR/Ka3hWbo2XXPxdYoWetzOTwmOFYrNa/tTwM78cLmsVvGwWdHHUVd24G3vi0Xyr0vQhUl063ijHxLiH9azaM3aVPMD8cHehKHpOtH5GWAnvw8ArI7DclYWEckK85YNM2YDXepM/vjJDHVXOgUcxTxpERKwj70SFIvT6q5ebMbLdYPpNLUM3YJ2wSKj+kO7kJBbDZNtPvKvQuDcRige3+YyaeUowcYX5lroy+WQ87VFOMG5bKDkVaSsXQZl+v1OtNh6vJ80pVMTOQ2CB2LxSTqCjeIiUjcw2rrvZsz2O4vwaZXBs3gtfLSK6LcB7vYWg84t9ymiFXhmZN04xJ5Qc6WNbdGKMR6jCsauRMNh7VucfYvLx2CXYYP8HVV4S9wOrrSZzxuotwK60e6koHrzxJlm5UCdoRIFikPw9g0jmf56zNXR9wpPh+XyksbG9JVs/3hRNmj4/t5t4nJTnwWEaQRKzAPbZngpMQ9Ql9tlThV+4yf43f70tBPexum45EAKWRXQHJOaNnVpl+SFAZ6ancawbPvehneqXvGRLt5omHZ1DRC/N7WGLC9XdfKA6E6L0nQupag/FcKTP630GuY6iDG9EI6Q8o3QvNmJp3KmxXoc7v70XVozB/B4+ddmFcQPcFKoTu7AlQlxzeOVqz6xcb+dOFotohLiJ25srRT/1XV3Za0DSuqQm6ARmaQVB7fGzlPASfzu2mNLhPzHBuAW1fitIuNHzt82nu1LezFPUXnC8x8K2PpQBWCgbaaH7FoYIB7KpHgcnQHvW5P5fKsV8AZv9hFRr2u5jUWh3zFstXSZGXEMj1RYVgY8bWqTLvHNWwE1KiqLGFUszUmjrVy8ShDFred6GwTq95Zoogvi2l1V9x7rdhw5QoXJxTDXaNjJD+hn7/kYfYr37Kw3TZirY2pysDwUDPfMZIi4cr3vnwyUVsFs9hK5M66Z8tpQ+dcUiCC3rgU28vFXlLZ8nmY2IkZ3i7MeLUCdQwGDHGxCCNE3yz2K6DRBD+8GdxrqQBGRhaa4MaON]]></content>
      <categories>
        <category>dairy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1010]]></title>
    <url>%2F2018%2F11%2F26%2FPAT%E7%94%B2%E7%BA%A71010%2F</url>
    <content type="text"><![CDATA[题意：给两个数，tags指明一个数的进制。问另外一个数是多少的时候两个数相等。给定的数最多是1e15，所以long long 可以存下。第二个数的进制可能非常大，比如第二个数是10，第一个数是1e10。那么第二个数进制是1e10的时候连个数是相等的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;const int N=1005;const int inf= 0x3f3f3f3f;typedef long long ll;using namespace std;map&lt;char, ll&gt; to;ll getVal(char str[], ll base)&#123; ll ret=0; for(int i=0; str[i]; i++)&#123; ret=ret*base + to[str[i]]; &#125; return ret;&#125;int check(char s[], ll base, ll tar)&#123; ll num=0; for(int i=0; s[i]; i++)&#123; num=num*base+to[s[i]]; if(num&gt;tar) return 1; if(num&lt;0) return 1; &#125; if(num&lt;tar) return -1; return 0;&#125;ll binarySearch(char s[], ll l, ll r, ll tar)&#123; while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; int flag=check(s, mid, tar); if(flag&gt;=0) r=mid-1; else if(flag&lt;0) l=mid+1; &#125; if(check(s, l, tar)==0) return l; return -1;&#125;int main () &#123; char num1[20], num2[20], tmp[20]; int kd; ll base; for(int i=0; i&lt;10; i++) to['0'+i]=i; for(char i='a'; i&lt;='z' ; i++) to[i]=i-'a'+10; while(~scanf("%s", num1))&#123; scanf("%s", num2); int len1=strlen(num1); int len2=strlen(num2); scanf("%d%lld", &amp;kd, &amp;base); if(kd==2)&#123; strcpy(tmp, num1); strcpy(num1, num2); strcpy(num2, tmp); &#125; ll tar=0; tar=getVal(num1, base); ll low=2; int i=0; while(num2[i]) low=max(to[num2[i++]]+1, low); ll ans=binarySearch(num2, low, tar+1, tar); if(ans==-1)&#123; puts("Impossible"); &#125; else&#123; printf("%lld\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manacher找出最长回文串]]></title>
    <url>%2F2018%2F11%2F21%2Fmanacher%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[熟悉算法的可能知道manacher在线性时间能够找出最长回文串长度，但是要想找出最长回文串是谁，需要做一些改进，这时需要分奇偶讨论，枚举中心点。该题目来源于LeetCode 第五题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: string longestPalindrome(string s) &#123; if(s=="") return ""; int idl=0, idr=0, anslen=0; int *r=new int[s.length()+5]; memset(r, 0, sizeof r); int mx=0, mid=0; //odd for(int i=0; i&lt;s.length(); i++)&#123; r[i]=i&lt;mx ? min(r[2*mid-i], mx-i) : 1; while(i-r[i]&gt;=0 &amp;&amp; i+r[i]&lt;=s.length() &amp;&amp; s[i-r[i]]==s[i+r[i]])&#123; r[i]++; &#125; if(i+r[i]&gt;mx)&#123; mid=i; mx=i+r[i]; &#125; if(anslen&lt;2*r[i]-1)&#123; anslen=2*r[i]-1; idl=i-r[i]+1; idr=i+r[i]-1; &#125; &#125; memset(r, 0, sizeof r); mx=0, mid=0; //even for(int i=0; i&lt;s.length()-1; i++)&#123; r[i]=i&lt;mx? min(r[2*mid-i], mx-i) : 0; while(i-r[i]&gt;=0 &amp;&amp; i+r[i]+1&lt;s.length() &amp;&amp; s[i-r[i]]==s[i+r[i]+1]) r[i]++; if(i+r[i]&gt;mx)&#123; mid=i; mx=i+r[i]; &#125; if(anslen&lt;2*r[i])&#123; anslen=2*r[i]; idl=i-r[i]+1; idr=i+r[i]; &#125; &#125; string ans=s.substr(idl, anslen); return ans; &#125;&#125;; 传统的代码 12345678910111213141516171819202122char Ma[MAXN*2]；int Mp[MAXN*2];void MAnacher(char s[], int len)&#123; int l=0; Ma[l++]='$'; Ma[l++]='#'; for(int i=0; i&lt;len; i++)&#123; Ma[l++]=s[i]; Ma[l++]='#'; &#125; Ma[l]=0; int mx=0, id=0; for(int i=0; i&lt;l; i++)&#123; Mp[i]=mx&gt;i?min(Mp[2*id-i], mx-i):1; while(Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx)&#123; mx=i+Mp[i]; id=i; &#125; &#125; //Mp[]中的最大值就是最长回文串的长度&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1055C]]></title>
    <url>%2F2018%2F11%2F12%2FCF1055C%2F</url>
    <content type="text"><![CDATA[题意： 给[l1,r1],d1,并且规定[l1,r1], [l1+d1, r1+d1]…[l1+k*d1, r1+k*d1]是happy区间，l2,r2,d2也如此，现在就是让求最长的连续区间，并且这个区间对1,2都是happy的 思路： 这个题一看就知道循环节，最小公倍数，但是直接暴力循环节超时，我们可以考虑这个式子 d1x+d2y=gcd(d1, d2) (mod最小公倍数)，我们知道，最大的答案是两区间较小者，所以我们应该让两区间左端点尽量重合，假如左端点相差dis，我们通过上面式子可以看出，我们可以调整x，y逼近dis 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e5+10;ll l1, l2, r1, r2, d1, d2;ll jiao(ll a1, ll b1, ll a2, ll b2)&#123; ll a3=max(a1, a2); ll b3=min(b1, b2); return max(0ll, b3-a3+1);&#125;int main()&#123; cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;d1&gt;&gt;l2&gt;&gt;r2&gt;&gt;d2; ll gd=__gcd(d1, d2); if(l1&lt;l2) swap(l1, l2), swap(r1, r2); ll dis=l1-l2; ll bei=dis/gd; ll ans=0; ans=max(ans, jiao(l1, r1, l2+bei*gd, r2+bei*gd)); ans=max(ans, jiao(l1, r1, l2+bei*gd+gd, r2+bei*gd+gd)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.11.02晚]]></title>
    <url>%2F2018%2F11%2F02%2F2018-11-02%E6%99%9A%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>dairy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-3543不错的dp]]></title>
    <url>%2F2018%2F11%2F01%2FZOJ-3543%E4%B8%8D%E9%94%99%E7%9A%84dp%2F</url>
    <content type="text"><![CDATA[题意： 给长为n-1字符串，包括‘I’,’D’,’?’三个字符，含义分别是： ‘I’比前面的数大 ‘D’比前面的数小 ‘？’不受限制 问题是有多少1~n的全排列满足这个关系串。 思路： 感觉挺难想的。设dp[i][j]代表1~i的全排列，以j数字结尾，并且满足这个关系串的种类数。 那么对于长度为i+1，如果是字符‘D’ dp[i+1][j]=sum(dp[i][k]) k=j~i-1 因为我们已经保证了i-1是满足的，当我们添加j使长度变为i，并且也要满足，就相当于前面大于等于j的数都+1，这样就变成了1~i满足关系串的全排列 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mo=1000000007;const int N=1e3+10;ll dp[N][N];ll sum[N];char s[N];int main()&#123; while(~scanf("%s", s+2))&#123; int n=strlen(s+2)+1; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) dp[i][j]=0; dp[1][1]=1; for(int i=2; i&lt;=n; i++)&#123; if(s[i]=='D')&#123; for(int j=i-1; j&gt;=1; j--) dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mo; &#125; else if(s[i]=='I')&#123; for(int j=2; j&lt;=i; j++) dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mo; &#125; else&#123; ll sum=0; for(int j=1; j&lt;i; j++) sum=(sum+dp[i-1][j])%mo; for(int j=1; j&lt;=i; j++) dp[i][j]=sum; &#125; &#125; ll sum=0; for(int i=1; i&lt;=n; i++) sum=(sum+dp[n][i])%mo; printf("%lld\n", sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维线段树模板]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这个模板是根据HDU-4819编写的。功能是用二维线段树进行 二维点修改和区间查询最小者和最大值。 二维线段树的思想跟一维一样，只不过一维是二分二叉树，二维 是四分四叉树。具体实现看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;using namespace std;const int LOGN = 10;const int MAXN = (1&lt;&lt;LOGN);const int MAXNODES = (3*(1&lt;&lt;(2*LOGN)) + 100);const int MAX_VAL = 0x3f3f3f3f;const int MIN_VAL = -0x3f3f3f3f;#define son(x) (p*4-2+x)//表示最大值，最小值信息的结构体struct dataInfo&#123; short posx, posy; int val; dataInfo()&#123; posx = posy = val = -1; &#125; dataInfo(short _posx, short _posy, int _val)&#123; posx=_posx; posy=_posy; val=_val; &#125;&#125;;//树的节点struct treeNode&#123; dataInfo maxv, minv; void reset()&#123; maxv = dataInfo(0, 0, INT_MIN); minv = dataInfo(0, 0, INT_MAX); &#125;&#125;nodes[MAXNODES];//得到节点的指针treeNode* getNode(int id)&#123; return &amp;nodes[id];&#125;//表示x、y的范围struct Interval&#123; int l, r; Interval()&#123;&#125; Interval(int _l, int _r)&#123; l=_l; r=_r; &#125; int mid()&#123; return (l+r)&gt;&gt;1; &#125; int len()&#123; return r-l+1; &#125; Interval left()&#123; return Interval(l, mid()); &#125; Interval right()&#123; return Interval(mid()+1, r); &#125; bool isIntersectWith(Interval&amp; tarI)&#123;//判断两区间是否相交 return !(l&gt;tarI.r || r&lt;tarI.l); &#125; bool isInclude(Interval&amp; tarI)&#123;//是否包含tarI区间 return l&lt;=tarI.l &amp;&amp; tarI.r&lt;=r; &#125; bool in(int v)&#123;//是否包含v点 return l&lt;=v &amp;&amp; v&lt;=r; &#125;&#125;;//建树void build_segtree(int p, Interval xI, Interval yI)&#123; if(xI.len()&lt;=0 || yI.len()&lt;=0)&#123; return; &#125; treeNode* now=getNode(p); now-&gt;reset(); if(xI.len() == 1 &amp;&amp; yI.len()==1)&#123; return; &#125; //分别为左上、右上、左下、右下的矩形区间 build_segtree( son(0), xI.left(), yI.left() ); build_segtree( son(1), xI.right(), yI.left() ); build_segtree( son(2), xI.left(), yI.right() ); build_segtree( son(3), xI.right(), yI.right() );&#125;//点修改bool insert_segtree(int p, Interval xI, Interval yI, int x, int y, int val)&#123; if(xI.len() &lt;= 0 || yI.len()&lt;=0)&#123; return false; &#125; if(!xI.in(x) || !yI.in(y) )&#123; return true; &#125; treeNode *now = getNode(p); if(xI.len()==1 &amp;&amp; yI.len()==1)&#123; now-&gt;maxv=now-&gt;minv =dataInfo(x, y, val); return true; &#125; bool isvalid[4]; isvalid[0]=insert_segtree( son(0), xI.left(), yI.left(), x, y, val); isvalid[1]=insert_segtree( son(1), xI.right(), yI.left(), x, y, val); isvalid[2]=insert_segtree( son(2), xI.left(), yI.right(), x, y, val); isvalid[3]=insert_segtree( son(3), xI.right(), yI.right(), x, y, val); now-&gt;reset(); for(int i=0; i&lt;4; i++)&#123; if(!isvalid[i]) continue;//只对有效的区间修改 treeNode *sonNode =getNode(son(i)); now-&gt;maxv=sonNode-&gt;maxv.val &gt; now-&gt;maxv.val?sonNode-&gt;maxv : now-&gt;maxv; now-&gt;minv=sonNode-&gt;minv.val &lt; now-&gt;minv.val?sonNode-&gt;minv : now-&gt;minv; &#125; return true;&#125;void query_segtree(int p, Interval xI, Interval yI, Interval tarXI, Interval tarYI, treeNode&amp; ans)&#123; if(xI.len()&lt;=0 || yI.len()&lt;=0)&#123; return; &#125; if(!tarXI.isIntersectWith(xI) || !tarYI.isIntersectWith(yI) )&#123; return; &#125; treeNode *now=getNode(p); if(ans.maxv.val&gt;=now-&gt;maxv.val &amp;&amp; ans.minv.val&lt;=now-&gt;minv.val)&#123; return; &#125; if(tarXI.isInclude(xI) &amp;&amp; tarYI.isInclude(yI))&#123; ans.maxv.val=max(ans.maxv.val, now-&gt;maxv.val); ans.minv.val=min(ans.minv.val, now-&gt;minv.val); return; &#125; query_segtree( son(0), xI.left(), yI.left(), tarXI, tarYI, ans ); query_segtree( son(1), xI.right(), yI.left(), tarXI, tarYI, ans ); query_segtree( son(2), xI.left(), yI.right(), tarXI, tarYI, ans ); query_segtree( son(3), xI.right(), yI.right(), tarXI, tarYI, ans );&#125;int main()&#123; int T, n, tmp, cas=0; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); build_segtree(1, Interval(1, n), Interval(1, n)); int tmp; for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; scanf("%d", &amp;tmp); insert_segtree(1, Interval(1, n), Interval(1, n), i, j, tmp); &#125; &#125; int m, x, y, sz; scanf("%d", &amp;m); printf("Case #%d:\n", ++cas); while(m--)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;sz); Interval XI, YI; XI.l=max(1, x-sz/2), XI.r=min(n, x+sz/2); YI.l=max(1, y-sz/2), YI.r=min(n, y+sz/2); treeNode ans; ans.reset(); query_segtree( 1, Interval(1, n), Interval(1, n), XI, YI, ans); printf("%d\n", (ans.maxv.val+ans.minv.val)/2); insert_segtree(1, Interval(1, n), Interval(1, n), x, y, (ans.maxv.val+ans.minv.val)/2); &#125; &#125; return 0;&#125; 上面是借鉴的网上的写法，因为他将各种都进行了封装，所以比较好理解。自己感觉竞赛还是简练一点比较好，下面代码是自己修改的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;const int N=810;#define son(x) (rt*4-2+x)struct node&#123; int mx, mn; void reset()&#123; mx=INT_MIN; mn=INT_MAX; &#125;&#125;tree[(N&lt;&lt;2)*(N&lt;&lt;2)];void build(int rt, int xl, int xr, int yl, int yr)&#123; if(xl&gt;xr || yl&gt;yr) return; tree[rt].reset(); if(xl==xr&amp;&amp;yl==yr) return; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; build(son(0), xl, midx, yl, midy); build(son(1), xl, midx, midy+1, yr); build(son(2), midx+1, xr, yl, midy); build(son(3), midx+1, xr, midy+1, yr);&#125;//push_up完全可以放在跟新里面 写起来更简洁void push_up(int rt, int xl, int xr, int yl, int yr)&#123; node&amp; now=tree[rt]; now.reset(); now.mx=max(now.mx, tree[son(0)].mx); now.mn=min(now.mn, tree[son(0)].mn); if(yl&lt;yr)&#123; now.mx=max(now.mx, tree[son(1)].mx); now.mn=min(now.mn, tree[son(1)].mn); &#125; if(xl&lt;xr)&#123; now.mx=max(now.mx, tree[son(2)].mx); now.mn=min(now.mn, tree[son(2)].mn); &#125; if(xl&lt;xr &amp;&amp; yl&lt;yr)&#123; now.mx=max(now.mx, tree[son(3)].mx); now.mn=min(now.mn, tree[son(3)].mn); &#125;&#125;//point updatevoid upd(int rt, int xl, int xr, int yl, int yr, int x, int y, int val)&#123; if(xl&gt;xr || yl&gt;yr) return; node&amp; now=tree[rt]; if(xl==xr&amp;&amp;xl==x &amp;&amp; yl==yr&amp;&amp;yl==y)&#123; now.mx=val; now.mn=val; return; &#125; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; if(x&lt;=midx &amp;&amp; y&lt;=midy)&#123; upd(son(0), xl, midx, yl, midy, x, y, val); &#125; else if(x&lt;=midx &amp;&amp; y&gt;midy)&#123; upd(son(1), xl, midx, midy+1, yr, x, y, val); &#125; else if(x&gt;midx &amp;&amp; y&lt;=midy)&#123; upd(son(2), midx+1, xr, yl, midy, x, y, val); &#125; else&#123; upd(son(3), midx+1, xr, midy+1, yr, x, y, val); &#125; push_up(rt, xl, xr, yl, yr);&#125;//interval querynode query(int rt, int xl, int xr, int yl, int yr, int qxl, int qxr, int qyl, int qyr)&#123; node tmp; tmp.reset(); if(xl&gt;xr || yl&gt;yr) return tmp; if(xl&gt;qxr || qxl&gt;xr || yl&gt;qyr || qyl&gt;yr) return tmp; if(qxl&lt;=xl &amp;&amp; xr&lt;=qxr &amp;&amp; qyl&lt;=yl &amp;&amp; yr&lt;=qyr)&#123; return tree[rt]; &#125; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; node ret; ret.reset(); if(qxl&lt;=midx &amp;&amp; qyl&lt;=midy)&#123; tmp=query(son(0), xl, midx, yl, midy, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxl&lt;=midx &amp;&amp; qyr&gt;midy)&#123; tmp=query(son(1), xl, midx, midy+1, yr, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxr&gt;midx &amp;&amp; qyl&lt;=midy)&#123; tmp=query(son(2), midx+1, xr, yl, midy, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxr&gt;midx &amp;&amp; qyr&gt;midy)&#123; tmp=query(son(3), midx+1, xr, midy+1, yr, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; return ret;&#125;int main()&#123; int T, n, cas=0; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); build(1, 1, n, 1, n); int tmp; for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; scanf("%d", &amp;tmp); upd(1, 1, n, 1, n, i, j, tmp); &#125; &#125; int m, x, y, sz; scanf("%d", &amp;m); printf("Case #%d:\n", ++cas); while(m--)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;sz); int qxl=max(1, x-sz/2), qxr=min(n, x+sz/2); int qyl=max(1, y-sz/2), qyr=min(n, y+sz/2); node ans; ans=query(1, 1, n, 1, n, qxl, qxr, qyl, qyr); printf("%d\n", (ans.mn + ans.mx)&gt;&gt;1); upd(1, 1, n, 1, n, x, y, (ans.mn+ans.mx)/2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4821 String --hash+map]]></title>
    <url>%2F2018%2F10%2F30%2FHDU-4821-String-hash-map%2F</url>
    <content type="text"><![CDATA[题意： 给上限为1e5的字符串，找出有多少长度为M*L的子串，并且该子串的M个长度为L的子串各不相同。 思路： 开始认为子串不想同的定义是每个位置的字符不相同，感觉说的有歧义。 two strings are considered as “diversified” if they don’t have the same character for every position. 最暴力的算法就是枚举所有长度为M*L的子串，判断hash子串是否合格。但是枚举子串是n^2的时间复杂度。可以仔细想一下，我们可以从下标1~L枚举起点，然后以这个起点用指针每次跳L步长。然后跟尺取原理似的一直保持map里的元素是M个。这样时间复杂度是O（L*n/L）,即O(n)。为什么用map去重而不用set，原因就是对于相同的我们记住它出现了几次，只有他出现的次数==0的时候才将它删去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+10;ull base[N], _hash[N], mul=37;char str[N];inline ull hash_str(int l, int r)&#123; return _hash[r]-_hash[l-1]*base[r-l+1];&#125;int main()&#123; int M, L; while(~scanf("%d%d", &amp;M, &amp;L))&#123; scanf("%s", str+1); int len=strlen(str+1); base[0]=1; _hash[0]=0; for(int i=1; i&lt;=len; i++)&#123; base[i]=base[i-1]*mul; _hash[i]=_hash[i-1]*mul+str[i]; &#125; map&lt;ull, int&gt; mp; int ans=0; for(int i=1; i&lt;=L; i++)&#123;//enum start point mp.clear(); for(int j=i; i+M*L-1&lt;=len &amp;&amp; j+L-1&lt;=len; j+=L)&#123; if(j-M*L&gt;=i)&#123; ull tmp=hash_str(j-M*L, j-M*L+L-1); mp[tmp]--; if(mp[tmp]==0) mp.erase(tmp); &#125; mp[hash_str(j, j+L-1)]++; if(mp.size()==M) ans++; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>map</tag>
        <tag>hash</tag>
      </tags>
  </entry>
</search>
