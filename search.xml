<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018.11.02晚]]></title>
    <url>%2F2018%2F11%2F02%2F2018-11-02%E6%99%9A%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>dairy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-3543不错的dp]]></title>
    <url>%2F2018%2F11%2F01%2FZOJ-3543%E4%B8%8D%E9%94%99%E7%9A%84dp%2F</url>
    <content type="text"><![CDATA[题意： 给长为n-1字符串，包括‘I’,’D’,’?’三个字符，含义分别是： ‘I’比前面的数大 ‘D’比前面的数小 ‘？’不受限制 问题是有多少1~n的全排列满足这个关系串。 思路： 感觉挺难想的。设dp[i][j]代表1~i的全排列，以j数字结尾，并且满足这个关系串的种类数。 那么对于长度为i+1，如果是字符‘D’ dp[i+1][j]=sum(dp[i][k]) k=j~i-1 因为我们已经保证了i-1是满足的，当我们添加j使长度变为i，并且也要满足，就相当于前面大于等于j的数都+1，这样就变成了1~i满足关系串的全排列 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mo=1000000007;const int N=1e3+10;ll dp[N][N];ll sum[N];char s[N];int main()&#123; while(~scanf("%s", s+2))&#123; int n=strlen(s+2)+1; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) dp[i][j]=0; dp[1][1]=1; for(int i=2; i&lt;=n; i++)&#123; if(s[i]=='D')&#123; for(int j=i-1; j&gt;=1; j--) dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mo; &#125; else if(s[i]=='I')&#123; for(int j=2; j&lt;=i; j++) dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mo; &#125; else&#123; ll sum=0; for(int j=1; j&lt;i; j++) sum=(sum+dp[i-1][j])%mo; for(int j=1; j&lt;=i; j++) dp[i][j]=sum; &#125; &#125; ll sum=0; for(int i=1; i&lt;=n; i++) sum=(sum+dp[n][i])%mo; printf("%lld\n", sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维线段树模板]]></title>
    <url>%2F2018%2F10%2F31%2F%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这个模板是根据HDU-4819编写的。功能是用二维线段树进行 二维点修改和区间查询最小者和最大值。 二维线段树的思想跟一维一样，只不过一维是二分二叉树，二维 是四分四叉树。具体实现看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;using namespace std;const int LOGN = 10;const int MAXN = (1&lt;&lt;LOGN);const int MAXNODES = (3*(1&lt;&lt;(2*LOGN)) + 100);const int MAX_VAL = 0x3f3f3f3f;const int MIN_VAL = -0x3f3f3f3f;#define son(x) (p*4-2+x)//表示最大值，最小值信息的结构体struct dataInfo&#123; short posx, posy; int val; dataInfo()&#123; posx = posy = val = -1; &#125; dataInfo(short _posx, short _posy, int _val)&#123; posx=_posx; posy=_posy; val=_val; &#125;&#125;;//树的节点struct treeNode&#123; dataInfo maxv, minv; void reset()&#123; maxv = dataInfo(0, 0, INT_MIN); minv = dataInfo(0, 0, INT_MAX); &#125;&#125;nodes[MAXNODES];//得到节点的指针treeNode* getNode(int id)&#123; return &amp;nodes[id];&#125;//表示x、y的范围struct Interval&#123; int l, r; Interval()&#123;&#125; Interval(int _l, int _r)&#123; l=_l; r=_r; &#125; int mid()&#123; return (l+r)&gt;&gt;1; &#125; int len()&#123; return r-l+1; &#125; Interval left()&#123; return Interval(l, mid()); &#125; Interval right()&#123; return Interval(mid()+1, r); &#125; bool isIntersectWith(Interval&amp; tarI)&#123;//判断两区间是否相交 return !(l&gt;tarI.r || r&lt;tarI.l); &#125; bool isInclude(Interval&amp; tarI)&#123;//是否包含tarI区间 return l&lt;=tarI.l &amp;&amp; tarI.r&lt;=r; &#125; bool in(int v)&#123;//是否包含v点 return l&lt;=v &amp;&amp; v&lt;=r; &#125;&#125;;//建树void build_segtree(int p, Interval xI, Interval yI)&#123; if(xI.len()&lt;=0 || yI.len()&lt;=0)&#123; return; &#125; treeNode* now=getNode(p); now-&gt;reset(); if(xI.len() == 1 &amp;&amp; yI.len()==1)&#123; return; &#125; //分别为左上、右上、左下、右下的矩形区间 build_segtree( son(0), xI.left(), yI.left() ); build_segtree( son(1), xI.right(), yI.left() ); build_segtree( son(2), xI.left(), yI.right() ); build_segtree( son(3), xI.right(), yI.right() );&#125;//点修改bool insert_segtree(int p, Interval xI, Interval yI, int x, int y, int val)&#123; if(xI.len() &lt;= 0 || yI.len()&lt;=0)&#123; return false; &#125; if(!xI.in(x) || !yI.in(y) )&#123; return true; &#125; treeNode *now = getNode(p); if(xI.len()==1 &amp;&amp; yI.len()==1)&#123; now-&gt;maxv=now-&gt;minv =dataInfo(x, y, val); return true; &#125; bool isvalid[4]; isvalid[0]=insert_segtree( son(0), xI.left(), yI.left(), x, y, val); isvalid[1]=insert_segtree( son(1), xI.right(), yI.left(), x, y, val); isvalid[2]=insert_segtree( son(2), xI.left(), yI.right(), x, y, val); isvalid[3]=insert_segtree( son(3), xI.right(), yI.right(), x, y, val); now-&gt;reset(); for(int i=0; i&lt;4; i++)&#123; if(!isvalid[i]) continue;//只对有效的区间修改 treeNode *sonNode =getNode(son(i)); now-&gt;maxv=sonNode-&gt;maxv.val &gt; now-&gt;maxv.val?sonNode-&gt;maxv : now-&gt;maxv; now-&gt;minv=sonNode-&gt;minv.val &lt; now-&gt;minv.val?sonNode-&gt;minv : now-&gt;minv; &#125; return true;&#125;void query_segtree(int p, Interval xI, Interval yI, Interval tarXI, Interval tarYI, treeNode&amp; ans)&#123; if(xI.len()&lt;=0 || yI.len()&lt;=0)&#123; return; &#125; if(!tarXI.isIntersectWith(xI) || !tarYI.isIntersectWith(yI) )&#123; return; &#125; treeNode *now=getNode(p); if(ans.maxv.val&gt;=now-&gt;maxv.val &amp;&amp; ans.minv.val&lt;=now-&gt;minv.val)&#123; return; &#125; if(tarXI.isInclude(xI) &amp;&amp; tarYI.isInclude(yI))&#123; ans.maxv.val=max(ans.maxv.val, now-&gt;maxv.val); ans.minv.val=min(ans.minv.val, now-&gt;minv.val); return; &#125; query_segtree( son(0), xI.left(), yI.left(), tarXI, tarYI, ans ); query_segtree( son(1), xI.right(), yI.left(), tarXI, tarYI, ans ); query_segtree( son(2), xI.left(), yI.right(), tarXI, tarYI, ans ); query_segtree( son(3), xI.right(), yI.right(), tarXI, tarYI, ans );&#125;int main()&#123; int T, n, tmp, cas=0; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); build_segtree(1, Interval(1, n), Interval(1, n)); int tmp; for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; scanf("%d", &amp;tmp); insert_segtree(1, Interval(1, n), Interval(1, n), i, j, tmp); &#125; &#125; int m, x, y, sz; scanf("%d", &amp;m); printf("Case #%d:\n", ++cas); while(m--)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;sz); Interval XI, YI; XI.l=max(1, x-sz/2), XI.r=min(n, x+sz/2); YI.l=max(1, y-sz/2), YI.r=min(n, y+sz/2); treeNode ans; ans.reset(); query_segtree( 1, Interval(1, n), Interval(1, n), XI, YI, ans); printf("%d\n", (ans.maxv.val+ans.minv.val)/2); insert_segtree(1, Interval(1, n), Interval(1, n), x, y, (ans.maxv.val+ans.minv.val)/2); &#125; &#125; return 0;&#125; 上面是借鉴的网上的写法，因为他将各种都进行了封装，所以比较好理解。自己感觉竞赛还是简练一点比较好，下面代码是自己修改的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;const int N=810;#define son(x) (rt*4-2+x)struct node&#123; int mx, mn; void reset()&#123; mx=INT_MIN; mn=INT_MAX; &#125;&#125;tree[(N&lt;&lt;2)*(N&lt;&lt;2)];void build(int rt, int xl, int xr, int yl, int yr)&#123; if(xl&gt;xr || yl&gt;yr) return; tree[rt].reset(); if(xl==xr&amp;&amp;yl==yr) return; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; build(son(0), xl, midx, yl, midy); build(son(1), xl, midx, midy+1, yr); build(son(2), midx+1, xr, yl, midy); build(son(3), midx+1, xr, midy+1, yr);&#125;//push_up完全可以放在跟新里面 写起来更简洁void push_up(int rt, int xl, int xr, int yl, int yr)&#123; node&amp; now=tree[rt]; now.reset(); now.mx=max(now.mx, tree[son(0)].mx); now.mn=min(now.mn, tree[son(0)].mn); if(yl&lt;yr)&#123; now.mx=max(now.mx, tree[son(1)].mx); now.mn=min(now.mn, tree[son(1)].mn); &#125; if(xl&lt;xr)&#123; now.mx=max(now.mx, tree[son(2)].mx); now.mn=min(now.mn, tree[son(2)].mn); &#125; if(xl&lt;xr &amp;&amp; yl&lt;yr)&#123; now.mx=max(now.mx, tree[son(3)].mx); now.mn=min(now.mn, tree[son(3)].mn); &#125;&#125;//point updatevoid upd(int rt, int xl, int xr, int yl, int yr, int x, int y, int val)&#123; if(xl&gt;xr || yl&gt;yr) return; node&amp; now=tree[rt]; if(xl==xr&amp;&amp;xl==x &amp;&amp; yl==yr&amp;&amp;yl==y)&#123; now.mx=val; now.mn=val; return; &#125; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; if(x&lt;=midx &amp;&amp; y&lt;=midy)&#123; upd(son(0), xl, midx, yl, midy, x, y, val); &#125; else if(x&lt;=midx &amp;&amp; y&gt;midy)&#123; upd(son(1), xl, midx, midy+1, yr, x, y, val); &#125; else if(x&gt;midx &amp;&amp; y&lt;=midy)&#123; upd(son(2), midx+1, xr, yl, midy, x, y, val); &#125; else&#123; upd(son(3), midx+1, xr, midy+1, yr, x, y, val); &#125; push_up(rt, xl, xr, yl, yr);&#125;//interval querynode query(int rt, int xl, int xr, int yl, int yr, int qxl, int qxr, int qyl, int qyr)&#123; node tmp; tmp.reset(); if(xl&gt;xr || yl&gt;yr) return tmp; if(xl&gt;qxr || qxl&gt;xr || yl&gt;qyr || qyl&gt;yr) return tmp; if(qxl&lt;=xl &amp;&amp; xr&lt;=qxr &amp;&amp; qyl&lt;=yl &amp;&amp; yr&lt;=qyr)&#123; return tree[rt]; &#125; int midx=(xl+xr)&gt;&gt;1, midy=(yl+yr)&gt;&gt;1; node ret; ret.reset(); if(qxl&lt;=midx &amp;&amp; qyl&lt;=midy)&#123; tmp=query(son(0), xl, midx, yl, midy, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxl&lt;=midx &amp;&amp; qyr&gt;midy)&#123; tmp=query(son(1), xl, midx, midy+1, yr, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxr&gt;midx &amp;&amp; qyl&lt;=midy)&#123; tmp=query(son(2), midx+1, xr, yl, midy, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; if(qxr&gt;midx &amp;&amp; qyr&gt;midy)&#123; tmp=query(son(3), midx+1, xr, midy+1, yr, qxl, qxr, qyl, qyr); ret.mx=max(ret.mx, tmp.mx); ret.mn=min(ret.mn, tmp.mn); &#125; return ret;&#125;int main()&#123; int T, n, cas=0; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); build(1, 1, n, 1, n); int tmp; for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; scanf("%d", &amp;tmp); upd(1, 1, n, 1, n, i, j, tmp); &#125; &#125; int m, x, y, sz; scanf("%d", &amp;m); printf("Case #%d:\n", ++cas); while(m--)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;sz); int qxl=max(1, x-sz/2), qxr=min(n, x+sz/2); int qyl=max(1, y-sz/2), qyr=min(n, y+sz/2); node ans; ans=query(1, 1, n, 1, n, qxl, qxr, qyl, qyr); printf("%d\n", (ans.mn + ans.mx)&gt;&gt;1); upd(1, 1, n, 1, n, x, y, (ans.mn+ans.mx)/2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4821 String --hash+map]]></title>
    <url>%2F2018%2F10%2F30%2FHDU-4821-String-hash-map%2F</url>
    <content type="text"><![CDATA[题意： 给上限为1e5的字符串，找出有多少长度为M*L的子串，并且该子串的M个长度为L的子串各不相同。 思路： 开始认为子串不想同的定义是每个位置的字符不相同，感觉说的有歧义。 two strings are considered as “diversified” if they don’t have the same character for every position. 最暴力的算法就是枚举所有长度为M*L的子串，判断hash子串是否合格。但是枚举子串是n^2的时间复杂度。可以仔细想一下，我们可以从下标1~L枚举起点，然后以这个起点用指针每次跳L步长。然后跟尺取原理似的一直保持map里的元素是M个。这样时间复杂度是O（L*n/L）,即O(n)。为什么用map去重而不用set，原因就是对于相同的我们记住它出现了几次，只有他出现的次数==0的时候才将它删去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+10;ull base[N], _hash[N], mul=37;char str[N];inline ull hash_str(int l, int r)&#123; return _hash[r]-_hash[l-1]*base[r-l+1];&#125;int main()&#123; int M, L; while(~scanf("%d%d", &amp;M, &amp;L))&#123; scanf("%s", str+1); int len=strlen(str+1); base[0]=1; _hash[0]=0; for(int i=1; i&lt;=len; i++)&#123; base[i]=base[i-1]*mul; _hash[i]=_hash[i-1]*mul+str[i]; &#125; map&lt;ull, int&gt; mp; int ans=0; for(int i=1; i&lt;=L; i++)&#123;//enum start point mp.clear(); for(int j=i; i+M*L-1&lt;=len &amp;&amp; j+L-1&lt;=len; j+=L)&#123; if(j-M*L&gt;=i)&#123; ull tmp=hash_str(j-M*L, j-M*L+L-1); mp[tmp]--; if(mp[tmp]==0) mp.erase(tmp); &#125; mp[hash_str(j, j+L-1)]++; if(mp.size()==M) ans++; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>map</tag>
        <tag>hash</tag>
      </tags>
  </entry>
</search>
